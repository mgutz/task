/**
 * License: MIT
 * @see https://github.com/epixa/chuckt/blob/master/LICENSE.md
 * @version 0.2.0
 */

/**
 * Convenience method for applying chuckt event functionality to a socket
 *
 * IMPORTANT NOTE: Using this method will override any existing onmessage
 * callback on the given socket, so this should only be used if the only
 * messages you expect to receive through the socket are generated by a
 * chuckt server implementation.
 *
 * @param socket
 */
export const init = function(socket) {
  var client = new Client(socket);
  socket.onmessage = function(e) {
    client.process(e.data);
  };
  return client;
};

/**
 * Enables Client event functionality on the given socket
 *
 * In terms of receiving responses from the backend, no assumptions are made.
 * Since the websocket API currently only supports a single onmessage
 * callback, the Client client app is responsible for calling chuck.process()
 * when a message is received from the backend. Messages do not have to be
 * pre-filtered -- if chuckt.process() is called on a non-chuckt message, it
 * will simply be ignored.
 *
 * The only hard requirement of the given socket is that it implements a
 * send() method that takes in a single message string. It is assumed, but
 * not required, that the send() method will transport the encoded message to
 * the backend.
 *
 * @constructor
 */
var Client = function(socket) {
  this.socket = socket;
  this.callbacks = new Callbacks();
  this.listeners = {};
}

/**
 * Emits an event that proxies through the socket connection
 *
 * In addition to the name of the event to fire, you can pass any number of
 * arguments and they will be sent along with the event.
 *
 * If the last argument passed is a function, then it is registered as a
 * callback and is invoked whenever receipt is acknowledged on the backend.
 *
 * Usage:
 *  chuckt.emit('my-event', 'foo', 'bar');
 *  sends: {"chuckt":{"event":"my-event","args":["foo","bar"]}}
 *
 *  chuckt.emit('my-event', 'foo', console.log);
 *  sends: {"chuckt":{"event":"my-event","args":["foo","bar"],"callbackid":0}}
 *     and console.log() is called if the backend returns a callback response
 *
 * @param event
 */
Client.prototype.emit = function(event) {
  var data = {event: event};
  var args = Array.prototype.slice.call(arguments).slice(1);

  if (args.length > 0 && typeof args[args.length - 1] == 'function') {
    var callback = args.pop();
    data.callbackid = this.callbacks.register(callback);
  }

  if (args.length > 0) {
    data.args = args;
  }
  this.socket.send(this.serialize(data));
};

Client.prototype.invoke = async function(event, ...args) {
  return new Promise((resolve, reject) => {
    this.emit(event, [...args], obj => {
      const {e: err, p: payload}
      if (obj.err) return reject(err);
      resolve(payload)
    });
  });
};

/**
 * Adds the given callback as a listener to the given event
 *
 * When an event is received from the backend, all of its listeners are fired
 * in order. Any arguments passed with the event will be passed to each
 * listener.
 *
 * @param event
 * @param callback
 */
Client.prototype.on = function(event, callback) {
  if (!this.listeners[event]) {
    this.listeners[event] = [];
  }
  this.listeners[event].push(callback);
};

/**
 * Removes event listeners
 *
 * If an event is specified, then only event listeners for that specific
 * event will be removed. If no event is specified, then all listeners
 * are removed.
 *
 * @param event
 */
Client.prototype.removeListeners = function(event) {
  if (typeof event === 'undefined') {
    this.listeners = {};
  } else {
    delete this.listeners[event];
  }
};

/**
 * Processes the given socket message
 *
 * Generally speaking, this method will be manually called from within the
 * socket's onmessage() callback.
 *
 * If the message is not a "chuckt" message, then it is ignored.
 *
 * If the message is a callback message, then the callback matching the
 * callbackid is invoked with any arguments that may also have been passed.
 *
 * If the message is an event message, then all listeners bound to that event
 * are fired in order with any arguments that may also have been passed.
 *
 * @param message
 */
Client.prototype.process = function(message) {
  if (message[0] !== '{') return;

  var parsed = this.deserialize(message);

  const {n: event, i: callbackId, e: err, p: payload} = parsed;

  // name or callback id required
  if (typeof event !== 'string' && typeof callbackId !== 'number') return;

  // message is a callback, so execute it
  if (callbackId) {
    this.callbacks.use(callbackid, parsed);
    return;
  }

  // message is an emitted event, so execute all corresponding listeners
  if (event) {
    if (!this.listeners[event]) return;
    for (var i in this.listeners[event]) {
      this.listeners[event][i].apply(this, payload);
    }
  }
};

/**
 * Serializes the given data as a json string with the chuckt prefix
 *
 * @param data
 * @return {*}
 */
Client.prototype.serialize = function(data) {
  return JSON.stringify(data);
};

Client.prototype.deserialize = function(data) {
  return JSON.parse(data);
};

/**
 * Callback collection
 *
 * Since callbacks are inherently volatile (once a registered callback is
 * fired, it is permanently deleted), some minor callback management is
 * necessary to minimize CPU and memory impact.
 *
 * @constructor
 */
var Callbacks = function() {
  this.callbacks = [];
  this.max = 0;
};

/**
 * Registers the given callback and returns the callback's id
 *
 * @param callback
 * @return {*}
 */
Callbacks.prototype.register = function(callback) {
  this.callbacks[++this.max] = callback;
  return this.max;
};

/**
 * Invokes the callback identified by the callbackid with any arguments
 *
 * @param callbackid
 * @param args
 */
Callbacks.prototype.use = function(callbackid, args) {
  this.callbacks[callbackid].apply(this, args || {});
  delete this.callbacks[callbackid];
};
